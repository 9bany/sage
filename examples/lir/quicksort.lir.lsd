const bitxor = proc(a: Int, b: Int) -> Int = core {
    bitwise-xor [SP], [SP - 1] pop
}, bitor = proc(a: Int, b: Int) -> Int = core {
    bitwise-or [SP], [SP - 1] pop
}, bitnand = proc(a: Int, b: Int) -> Int = core {
    bitwise-nand [SP], [SP - 1] pop
}, bitand = proc(a: Int, b: Int) -> Int = core {
    bitwise-and [SP], [SP - 1] pop
}, bitnot = proc(x: Int) -> Int = core {
    bitwise-not [SP]
}, inc = proc(x: &Int) -> None = core {
    inc [[SP]]
    pop
}, dec = proc(x: &Int) -> None = core {
    dec [[SP]]
    pop
}, lt = proc(a: Int, b: Int) -> Bool = core {
    lt [SP - 1], [SP], A pop
    mov A, [SP]
}, lte = proc(a: Int, b: Int) -> Bool = core {
    lte [SP - 1], [SP], A pop
    mov A, [SP]
}, gt = proc(a: Int, b: Int) -> Bool = core {
    gt [SP - 1], [SP], A pop
    mov A, [SP]
}, gte = proc(a: Int, b: Int) -> Bool = core {
    gte [SP - 1], [SP], A pop
    mov A, [SP]
}, eq = proc(a: Int, b: Int) -> Bool = core {
    eq [SP - 1], [SP], A pop
    mov A, [SP]
}, neq = proc(a: Int, b: Int) -> Bool = core {
    neq [SP - 1], [SP], A pop
    mov A, [SP]
}, and = proc(a: Bool, b: Bool) -> Bool = core {
    and [SP], [SP - 1] pop
}, put = proc(n: Int) -> None = core {
    put [SP]
    pop
}, alloc = proc(n: Int) -> &Int = std {
    alloc [SP]
}, free = proc(n: &Int) -> None = std {
    free [SP]
} in

const putint = proc(n: Int) -> None = std {
    put-int [SP]
    pop
} in
const putchar = proc(ch: Char) -> None = std {
    put-char [SP]
    pop
} in

proc min(x: Int, y: Int) -> Int = {
    if (lt(x, y)) x else y
} in
proc max(x: Int, y: Int) -> Int = {
    if (gt(x, y)) x else y
} in


type List = struct { data: Int, next: &List } in

proc sort(node: &List) -> None = {
    if (node->next as Cell as Int + 128) {
        sort(node->next);
        let a = min(node->data, node->next->data),
            b = max(node->data, node->next->data)
            in {
            if (b - node->data) {
                sort(node->next);
            };
            node->data = a;
            node->next->data = b;
        };
    }
} in

proc len(node: &List) -> Int = {
    if (node as Cell as Int + 128) {
        len(node->next) + 1
    } else {
        0
    }
} in

proc neq(a: Int, b: Int) -> Bool = {
    (if ((a - b) as Bool) 1 else 0) as Bool
} in

proc index(node: &List, n: Int) -> &List = {
    while n {
        node = node->next;
        n = n - 1;
    };
    node
} in

proc swapi(a: &Int, b: &Int) -> None = {
    let tmp = (*a) in {
        (*a) = *b;
        (*b) = tmp;
    }
} in

proc partition_arr(arr: &Int, low: Int, high: Int) -> Int = {
    let pivot = arr[high],
        i = low - 1,
        j = low in {
        while lt(j, high) {
            if (lte(arr[j], pivot)) {
                inc(&i);
                swapi(&arr[j], &arr[i]);
            };
            inc(&j);
        };
        swapi(&arr[i + 1], &arr[high]);
        i + 1
    }
} in

proc quicksort_arr(arr: &Int, low: Int, high: Int) -> None = {
    if (lt(low, high)) {
        let pi = partition_arr(arr, low, high) in {
            quicksort_arr(arr, low, pi - 1);
            quicksort_arr(arr, pi + 1, high);
        }
    }
} in

const SIZE = 1000 in
let arr: &Int = alloc(SIZE * 2), i = 0, a = 5, b = 6 in {
    while lt(i, SIZE) {
        arr[i] = if (i % 2) i else (SIZE - i);
        putint(arr[i]); putchar(';');
        inc(&i);
    };
    quicksort_arr(arr, 0, SIZE - 1);
    putchar('\n');
    i = 0;
    while lt(i, SIZE) {
        putint(arr[i]); putchar(';');
        inc(&i);
    }
}