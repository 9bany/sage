
enum Math {
    Add(&Math, &Math),
    Sub(&Math, &Math),
    Mul(&Math, &Math),
    Div(&Math, &Math),
    Num Int
}

proc eval(m: &Math): Int = match *m {
    of Add(lhs, rhs) => eval(lhs) + eval(rhs),
    of Add(lhs, rhs) => eval(lhs) + eval(rhs),
    of Sub(lhs, rhs) => eval(lhs) - eval(rhs),
    of Mul(lhs, rhs) => eval(lhs) * eval(rhs),
    of Div(lhs, rhs) => eval(lhs) / eval(rhs),
    of Num n => n
};

// 2 * 3 + 6
let m = new Math of Add (
    new Math of Mul (
        new Math of Num 2,
        new Math of Num 3
    ),
    new Math of Num 6
);
print(eval(m), "\n");

proc freeMath(m: &Math) {
    match *m {
        of Add(lhs, rhs)
        | of Sub(lhs, rhs)
        | of Mul(lhs, rhs)
        | of Div(lhs, rhs) => {
            freeMath(lhs);
            freeMath(rhs);
        },
        _ => {}
    }
    del m;
}

freeMath(m);

enum List {
    Nil,
    Cons {
        data: Int,
        next: &List
    }
}

proc printList(list: &List) {
    match *list {
        of Nil => print("Nil"),
        of Cons { data, next = &of Nil } => {
            print("next element is nil");
            print(data);
        },
        of Cons { data, next = &of Cons {data = 5, next} } => {
            print("idk the next list item is 5 i guess");
        },
        of Cons { data, next } => {
            print(data, " ");
            printList(next);
        },
        _ => {}
    }
}

proc sumList(list: &List): Int {
    match *list {
        of Nil => 0,
        of Cons { data, next } => data + sumList(next)
    }
}

proc freeList(list: &List) {
    match *list {
        of Nil => {},
        of Cons { data, next } => {
            freeList(next);
        }
    }
    del list;
}

let list = new List of Cons {
    data = 5,
    next = new List of Cons {
        data = 6,
        next = new List of Cons {
            data = 7,
            next = new List of Nil
        }
    }
};

printList(list);
print(" -> ", sumList(list), "\n");
freeList(list);

let p = {x = 2, y = 3};
match p {
    {x = 2, y} => print("x is 2: ", p, "\n"),
    {x, y = 2} => print("y is 2: ", p, "\n"),
    otherwise => print("neither x nor y is 2: ", otherwise, "\n")
}

enum Tree {
    Leaf Int,
    Node {
        left: &Tree,
        right: &Tree
    }
}

proc printTree(tree: &Tree) {
    match *tree {
        of Leaf x => print(x, " "),
        of Node { left, right } => {
            print("(");
            printTree(left);
            print(", ");
            printTree(right);
            print(")");
        }
    }
}

proc freeTree(tree: &Tree) {
    match *tree {
        of Leaf _ => (),
        of Node { left, right } => {
            freeTree(left);
            freeTree(right);
        }
    }
    del tree;
}

let tree = new Tree of Node {
    left = new Tree of Node {
        left = new Tree of Leaf 1,
        right = new Tree of Leaf 2
    },
    right = new Tree of Node {
        left = new Tree of Leaf 3,
        right = new Tree of Leaf 4
    }
};

printTree(tree);
freeTree(tree);


const LEN1 = 8,
    LEN2 = 24;


proc array(x: [Char * LEN1]): [Char * LEN2] {
    let result = [
        ' ', ' ', ' ', ' ', 
        ' ', ' ', ' ', ' ', 
        ' ', ' ', ' ', ' ', 
        ' ', ' ', ' ', ' ',
        ' ', ' ', ' ', ' ', 
        ' ', ' ', ' ', ' ', 
    ];

    for let i=0; i < LEN2; i+=1 {
        result[i] = x[i % LEN1];
    }

    return result;
}

print(array("test.123"));

let x = 5,
    y = 6,
    z = 7 in print(x + y + z);

let w = 5, test = "hmm", z = List of Nil;

let test = new List of Cons { data = 5, next = new List of Nil };

freeList(test);