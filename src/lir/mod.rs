//! # LIR (Low Intermediate Representation) Module
//!
//! This module contains a decently sized typechecked intermediate representation for the virtual machine.
//! The LIR, unlike the VM and the assembly language, is *not* split into two variants: there is only one variant.
//! The LIR compiler will generate core assembly code *by default* for the LIR, but will revert to the standard
//! variant if unsupported instructions or types are encountered (such as floating point operations or float types).
//!
//! ## Index
//!
//! 1. [Types](./enum.Type.html)
//! 2. [Constants](./enum.ConstExpr.html) and [Expressions](./enum.Expr.html)
//! 3. [Core Builtins](struct.CoreBuiltin.html) and [Standard Builtins](struct.StandardBuiltin.html)
//! 4. [Compilation Errors](./enum.Error.html)

//! ## Purpose
//!
//! The purpose of the LIR is to provide a powerful backend for the next stage of IR. Most of the heavy lifting
//! of the actual compilation process is done by this stage of the compiler: typechecking, constant folding,
//! compiling to assembly, dealing with the two variants of the virtual machine, and so on. The stages of IR
//! above this simply implement features like macros and tagged-unions: very simple things which map 1:1 with
//! generated LIR code.
//!
//! ## Features
//!
//! 1. The Type System
//!
//! LIR's type system is very good for compiling directly to assembly. LIR supports the following types:
//!
//! - None (the void type)
//! - Never (the type of an expression which never returns a value: such as a `return` expression)
//! - Int (a signed integer)
//! - Float (a floating point number)
//! - Bool (a boolean value)
//! - Char (a single character)
//! - Cell (the most basic unit of memory)
//! - Pointer (a pointer to another given type)
//! - Array (an array with elements, with a constant size expression)
//! - Proc (a procedure with a list of arguments and a return type)
//! - Tuple (a tuple with a list of distinct types. this is the product type)
//! - Struct (a tuple with named fields)
//! - Union (a union of types. this is the sum type when combined with a tag)
//! - Enum (an enumeration with a list of variants. this is like a C enum, not a Rust enum)
//! - Let (a type which allows the user to bind a type under a given name in another type expression)
//!
//! The Let type is extremely powerful, allowing users to create recursive types *inline*: without
//! binding them to a name under a LetType expression. Additionally, Let types are checked for equality
//! *structurally*, and this also works for comparing recursive types. There are many examples of this in `tests/lir.rs`.
//!
//! 2. The Constant Folding
//!
//! LIR also provides constant expressions to allow the user to do as much as possible during compile time.
//! This also makes it simpler to do compile-time optimizations.
//!
//! 3. Expressions
//!
//! The expressions that LIR uses to represent the program are very simple, and very powerful.
//! Arrays are kept distinct from Pointers (unlike in C), and so expressions can return stack allocated arrays without a problem.
//! Arrays can also be indexed without a pointer to the array, and so on. LIR supports getting members of tuples, structs,
//! and unions, and also getting their references as well.
//!
//! 4. Compilation Process
//!
//! LIR is designed to be able to compile *as much as possible* to the core variant of the assembly language. As long as you don't
//! use floating point operations or standard builtins (`alloc` and `free`), you can compile to the core variant. Recursive types,
//! *inlined* recursive types, mutually recursive types, recursive functions, and core builtins are all supported without a problem.
//! **The LIR compiler will only use a standard instruction if it has to.**

mod compile;
mod env;
mod expr;
mod parse;
mod types;

pub use compile::*;
pub use env::*;
pub use expr::*;
pub use parse::*;
pub use types::*;

use core::fmt::{Debug, Display, Formatter, Result as FmtResult};

/// Simplify an expression while maintaining structural equality.
pub trait Simplify: Sized {
    /// Simplify an expression while maintaining structural equality.
    fn simplify(self, env: &Env) -> Result<Self, Error> {
        self.simplify_checked(env, 0)
    }

    /// Simplify an expression while maintaining structural equality, but limit
    /// the number of recursive calls to prevent stack overflow. `i` is a
    /// counter to prevent infinite recursion.
    fn simplify_checked(self, env: &Env, i: usize) -> Result<Self, Error>;
}

/// An LIR compilation error.
#[derive(Clone, Debug)]
pub enum Error {
    /// An error caused by trying to assemble invalid code generated by the compiler.
    /// This should be taken seriously, unless the error is due to an invalid handwritten builtin.
    AssemblyError(crate::asm::Error),

    /// The variant of an enum is not defined.
    VariantNotFound(Type, String),
    /// Tried to access an undefined member of a tuple, struct, or union.
    MemberNotFound(Expr, ConstExpr),
    /// Recursion depth exceeded when trying to evaluate a constant expression.
    RecursionDepthConst(ConstExpr),
    /// Recursion depth exceeded when trying to confirm a type's equality to another type.
    CouldntSimplify(Type, Type),
    RecursionDepthTypeEquality(Type, Type),
    /// Got another type when expecting an integer, bool, or char.
    NonIntegralConst(ConstExpr),
    /// Tried to instantiate a type that cannot be sized.
    /// This is a problem because we cannot manage the stack if we cannot know the size of the type.
    UnsizedType(Type),
    /// Tried to dereference a non-pointer.
    DerefNonPointer(Expr),
    /// Tried to apply a non-procedure to some arguments.
    ApplyNonProc(Expr),
    /// Expected a symbol, but got something else.
    NonSymbol(ConstExpr),
    /// Invalid `Index` expression (incorrect types).
    InvalidIndex(Expr),
    /// Invalid `Refer` expression. The compiler was not able to calculate the address of the expression.
    InvalidRefer(Expr),
    /// Invalid unary operation (negate, not) expression (incorrect types).
    InvalidUnaryOp(Box<dyn UnaryOp>, Expr),
    /// Invalid unary op types (incorrect types).
    InvalidUnaryOpTypes(Box<dyn UnaryOp>, Type),
    /// Invalid binary operation (add, subtract, and, or) expression (incorrect types).
    InvalidBinaryOp(Box<dyn BinaryOp>, Expr, Expr),
    /// Invalid binary op types (incorrect types).
    InvalidBinaryOpTypes(Box<dyn BinaryOp>, Type, Type),
    /// Invalid ternary operation (if) expression (incorrect types).
    InvalidTernaryOp(Box<dyn TernaryOp>, Expr, Expr, Expr),
    /// Invalid ternary op types (incorrect types).
    InvalidTernaryOpTypes(Box<dyn TernaryOp>, Type, Type, Type),
    /// Invalid assignment operation (assign, add_assign, subtract_assign, and_assign, or_assign) expression (incorrect types).
    InvalidAssignOp(Box<dyn AssignOp>, Expr, Expr),
    /// Invalid assign op types (incorrect types).
    InvalidAssignOpTypes(Box<dyn AssignOp>, Type, Type),

    /// Mismatched types
    MismatchedTypes {
        expected: Type,
        found: Type,
        expr: Expr,
    },

    /// A symbol was used, but not defined.
    SymbolNotDefined(String),
    /// A type was used, but not defined.
    TypeNotDefined(String),
    /// Tried to create an array with a negative length.
    NegativeArrayLength(Expr),

    /// Tried to use a pattern that is not valid for the given type.
    InvalidPatternForType(Type, Pattern),
    /// Tried to use a pattern that is not valid for the given expression.
    InvalidPatternForExpr(Expr, Pattern),

    /// Tried to match over an expression that cannot be matched over.
    InvalidMatchExpr(Expr),

    /// Invalid pattern for a match expression.
    NonExhaustivePatterns { patterns: Vec<Pattern>, expr: Expr },

    /// Invalid type casting expression.
    InvalidAs(Expr, Type, Type),

    /// Invalid constant expression.
    InvalidConstExpr(ConstExpr),

    /// Expression uses an operation unsupported by the target.
    UnsupportedOperation(Expr),

    /// Tried to define a type that already exists.
    TypeRedefined(String),

    /// Unused expression returned a non-None value.
    UnusedExpr(Expr, Type),

    /// Invalid number of template arguments to a type.
    InvalidTemplateArgs(Type),

    /// Tried to apply a non-template type to some arguments.
    ApplyNonTemplate(Type),

    /// Tried to get the size of a template type.
    SizeOfTemplate(Type),

    /// Tried to  compile a polymorphic procedure without monomorphing it.
    CompilePolyProc(PolyProcedure),

    /// Cannot monomorphize a constant expression.
    InvalidMonomorphize(ConstExpr),
}

/// Create an IR error from an assembly error.
impl From<crate::asm::Error> for Error {
    fn from(e: crate::asm::Error) -> Self {
        Self::AssemblyError(e)
    }
}

impl Display for Error {
    fn fmt(&self, f:  &mut Formatter) -> FmtResult {
        match self {
            Self::MismatchedTypes { expected, found, expr } => {
                write!(f, "mismatched types: expected {}, found {} in {}", expected, found, expr)
            }
            Self::VariantNotFound(ty, variant) => {
                write!(f, "variant {} not found in {}", variant, ty)
            }
            Self::MemberNotFound(expr, member) => {
                write!(f, "member {} not found in {}", member, expr)
            }
            Self::RecursionDepthConst(expr) => {
                write!(f, "recursion depth exceeded when trying to evaluate {}", expr)
            }
            Self::CouldntSimplify(ty1, ty2) => {
                write!(f, "couldn't simplify {} to {}", ty1, ty2)
            }
            Self::RecursionDepthTypeEquality(ty1, ty2) => {
                write!(f, "recursion depth exceeded when trying to confirm {} == {}", ty1, ty2)
            }
            Self::NonIntegralConst(expr) => {
                write!(f, "got non-integral constant expression {}", expr)
            }
            Self::UnsizedType(ty) => {
                write!(f, "tried to instantiate unsized type {}", ty)
            }
            Self::DerefNonPointer(expr) => {
                write!(f, "tried to dereference non-pointer {}", expr)
            }
            Self::ApplyNonProc(expr) => {
                write!(f, "tried to apply non-procedure {}", expr)
            }
            Self::NonSymbol(expr) => {
                write!(f, "expected symbol, found {}", expr)
            }
            Self::InvalidIndex(expr) => {
                write!(f, "invalid index expression {}", expr)
            }
            Self::InvalidRefer(expr) => {
                write!(f, "invalid refer expression {}", expr)
            }
            Self::InvalidUnaryOp(op, expr) => {
                write!(f, "invalid unary operation {} {}", op, expr)
            }
            Self::InvalidUnaryOpTypes(op, ty) => {
                write!(f, "invalid unary operation {} for type {}", op, ty)
            }
            Self::InvalidBinaryOp(op, expr1, expr2) => {
                write!(f, "invalid binary operation {} {} {}", op, expr1, expr2)
            }
            Self::InvalidBinaryOpTypes(op, ty1, ty2) => {
                write!(f, "invalid binary operation {} for types {} and {}", op, ty1, ty2)
            }
            Self::InvalidTernaryOp(op, expr1, expr2, expr3) => {
                write!(f, "invalid ternary operation {} {} {} {}", op, expr1, expr2, expr3)
            }
            Self::InvalidTernaryOpTypes(op, ty1, ty2, ty3) => {
                write!(f, "invalid ternary operation {} for types {}, {}, and {}", op, ty1, ty2, ty3)
            }
            Self::InvalidAssignOp(op, expr1, expr2) => {
                write!(f, "invalid assignment operation {} {} {}", op, expr1, expr2)
            }
            Self::InvalidAssignOpTypes(op, ty1, ty2) => {
                write!(f, "invalid assignment operation {} for types {} and {}", op, ty1, ty2)
            }
            Self::SymbolNotDefined(sym) => {
                write!(f, "symbol {} not defined", sym)
            }
            Self::TypeNotDefined(ty) => {
                write!(f, "type {} not defined", ty)
            }
            Self::NegativeArrayLength(expr) => {
                write!(f, "negative array length {}", expr)
            }
            Self::InvalidPatternForType(ty, pat) => {
                write!(f, "invalid pattern {} for type {}", pat, ty)
            }
            Self::InvalidPatternForExpr(expr, pat) => {
                write!(f, "invalid pattern {} for expression {}", pat, expr)
            }
            Self::InvalidMatchExpr(expr) => {
                write!(f, "invalid match expression {}", expr)
            }
            Self::NonExhaustivePatterns { patterns, expr } => {
                write!(f, "non-exhaustive patterns {:?} for expression {}", patterns, expr)
            }
            Self::InvalidAs(expr, ty1, ty2) => {
                write!(f, "invalid as expression {} for types {} and {}", expr, ty1, ty2)
            }
            Self::InvalidConstExpr(expr) => {
                write!(f, "invalid constant expression {}", expr)
            }
            Self::UnsupportedOperation(expr) => {
                write!(f, "unsupported operation {}", expr)
            }
            Self::TypeRedefined(ty) => {
                write!(f, "type {} redefined", ty)
            }
            Self::UnusedExpr(expr, ty) => {
                write!(f, "unused expression {} of type {}", expr, ty)
            }
            Self::InvalidTemplateArgs(ty) => {
                write!(f, "invalid template arguments for type {}", ty)
            }
            Self::ApplyNonTemplate(ty) => {
                write!(f, "tried to apply non-template type {}", ty)
            }
            Self::SizeOfTemplate(ty) => {
                write!(f, "tried to get size of template type {}", ty)
            }
            Self::CompilePolyProc(proc) => {
                write!(f, "tried to compile polymorphic procedure {}", proc)
            }
            Self::AssemblyError(e) => {
                write!(f, "assembly error: {:?}", e)
            }
            Self::InvalidMonomorphize(expr) => {
                write!(f, "invalid monomorphization of constant expression {}", expr)
            }
        }
    }
}