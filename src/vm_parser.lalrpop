use ::std::{str::FromStr, collections::BTreeMap};
use crate::vm::*;

grammar;


pub CoreProgram: CoreProgram = CoreOp* => CoreProgram(<>);
pub StandardProgram: StandardProgram = StandardOp* => StandardProgram(<>);

CoreOp: CoreOp = {
    "set" <IntLit> => CoreOp::Set(<>),
    "fun" => CoreOp::Function,
    "call" => CoreOp::Call,
    "ret" => CoreOp::Return,

    "while" => CoreOp::While,
    "if" => CoreOp::If,
    "else" => CoreOp::Else,
    "end" => CoreOp::End,
    
    "sav" => CoreOp::End,
    "res" => CoreOp::Restore,
    "mov" <IntLit> => CoreOp::Move(<>),

    "where" => CoreOp::Where,
    "deref" => CoreOp::Deref,
    "ref" => CoreOp::Refer,

    "index" => CoreOp::Index,
    "swap" => CoreOp::Swap,
    "add" => CoreOp::Add,
    "sub" => CoreOp::Sub,
    "mul" => CoreOp::Mul,
    "div" => CoreOp::Div,
    "rem" => CoreOp::Rem,
    "gez" => CoreOp::IsNonNegative,

    "get" => CoreOp::Get,
    "put" => CoreOp::Put,
}

StandardOp: StandardOp = {
    CoreOp => StandardOp::CoreOp(<>),
    "set-f" <FloatLit> => StandardOp::Set(<>),
    "to-float" => StandardOp::ToFloat,
    "to-int" => StandardOp::ToInt,
    
    "pow" => StandardOp::Pow,
    "add-f" => StandardOp::Add,
    "sub-f" => StandardOp::Sub,
    "mul-f" => StandardOp::Mul,
    "div-f" => StandardOp::Mul,
    "rem-f" => StandardOp::Rem,

    "sin" => StandardOp::Sin,
    "cos" => StandardOp::Cos,
    "tan" => StandardOp::Tan,
    "asin" => StandardOp::ASin,
    "acos" => StandardOp::ACos,
    "atan" => StandardOp::ATan,

    "alloc" => StandardOp::Alloc,
    "free" => StandardOp::Free,

    "put-int" => StandardOp::PutInt,
    "put-char" => StandardOp::PutChar,
    "put-float" => StandardOp::PutFloat,

    "get-int" => StandardOp::GetInt,
    "get-char" => StandardOp::GetChar,
    "get-float" => StandardOp::GetFloat,
}

StringLit: String = <s:r#""(\\.|[^"])*""#> => String::from(&s[1..s.len()-1]).replace("\\\"", "\"").replace("\\n", "\n").replace("\\r", "\r").replace("\\t", "\t").replace("\\0", "\0");
CharLit: char = <s:r#"'(\\.|[^'])'"#> => s.replace("\\'", "'").replace("\\n", "\n").replace("\\r", "\r").replace("\\t", "\t").replace("\\0", "\0").chars().nth(1).unwrap() as char;
IntLit: isize = <s:r"-?[0-9]\d*"> => isize::from_str(s).unwrap();
FloatLit: f64 = {
    r"-?([1-9][0-9]*|[0])[.]([0-9]+)?" => <>.to_string().parse::<f64>().unwrap(),
}
Symbol: String = r"[a-zA-Z_][a-zA-Z0-9_]*" => <>.to_string();


Tuple<T>: Vec<T> = {
    "(" <mut list: (<T> ",")+> <end:T?> ")" => {
        match end {
            None => list,
            Some(val) => {
                list.push(val);
                list
            }
        }
    }
}

Array<T>: Vec<T> = List<"[", T, ",", "]"> => <>;
Dict<K, V>: Vec<(K, V)> = List<"{", (<K> ":" <V>), ",", "}"> => <>;

List<Begin, T, Sep, End>: Vec<T> = {
    <first:Begin> <list: (<T> <Sep>)*> <end:T?> <last:End> => {
        match end {
            None => list.iter().map(|(v, s)| v.clone()).collect(),
            Some(val) => {
                let mut list: Vec<_> = list.iter().map(|(v, s)| v.clone()).collect();
                list.push(val);
                list
            }
        }
    }
}