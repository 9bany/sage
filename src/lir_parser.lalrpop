use ::std::{str::FromStr, collections::BTreeMap};
use crate::lir::*;
use crate::asm::{Location, CoreOp, StandardOp, SP, FP, A, B, C, D, E, F};

grammar;


Type: Type = {
    "let" <var: Symbol> "=" <t: Type> "in" <ret: Type> => Type::Let(var, Box::new(t), Box::new(ret)),
    "proc" <args: List<"(", Type, ",", ")">> "->" <ret: Type> => Type::Proc(args, Box::new(ret)),
    TypeTerm => <>,
}

TypeTerm: Type = {
    Symbol => Type::Symbol(<>),
    "(" <Type> ")" => <>,
    Tuple<Type> => Type::Tuple(<>),
    "&" <Type> => Type::Pointer(Box::new(<>)),
    "[" <t: Type> "*" <size: ConstExpr> "]" => Type::Array(Box::new(t), Box::new(size)),
    "Int" => Type::Int,
    "Float" => Type::Float,
    "Char" => Type::Char,
    "Bool" => Type::Bool,
    "Cell" => Type::Cell,
    "None" => Type::None,
    "enum" <List<"{", Symbol, ",", "}">> => Type::Enum(<>.into_iter().collect()),
    "union" <Dict<Symbol, Type>> => Type::Union(<>.into_iter().collect()),
    "struct" <Dict<Symbol, Type>> => Type::Struct(<>.into_iter().collect()),
}

pub ConstExpr: ConstExpr = {
    "proc" <args: List<"(", (<Symbol> ":" <Type>), ",", ")">> "->" <ret: Type> "=" <body: Block> => ConstExpr::Proc(Procedure::new(args, ret, body)),
    "core" <args: List<"(", (<Symbol> ":" <Type>), ",", ")">> "->" <ret: Type> "=" "{" <body: CoreOp*> "}" => ConstExpr::CoreBuiltin(
        CoreBuiltin {
            name: String::new(),
            args,
            ret,
            body,
        }
    ),
    "std" <args: List<"(", (<Symbol> ":" <Type>), ",", ")">> "->" <ret: Type> "=" "{" <body: StandardOp*> "}" => ConstExpr::StandardBuiltin(
        StandardBuiltin {
            name: String::new(),
            args,
            ret,
            body,
        }
    ),
    <variant: Symbol> "of" <t: TypeTerm> => ConstExpr::Of(t, variant).into(),
    Symbol => ConstExpr::Symbol(<>),
    IntLit => ConstExpr::Int(<> as i32),
    FloatLit => ConstExpr::Float(<>),
    CharLit => ConstExpr::Char(<>),
    "true" => ConstExpr::Bool(true),
    "false" => ConstExpr::Bool(false),
    "Null" => ConstExpr::Null,
    "None" => ConstExpr::None,
    "sizeof" "(" <Type> ")" => ConstExpr::SizeOfType(<>),
    "sizeofexpr" "(" <Expr> ")" => ConstExpr::SizeOfExpr(Box::new(<>)),
    "(" ")" => ConstExpr::None,
}

pub Expr: Expr = {
    "core" "{" <body: CoreOp*> "}" => ConstExpr::CoreBuiltin(CoreBuiltin {
        name: format!("block"),
        args: vec![],
        ret: Type::Any,
        body,
    }).app(vec![]),
    "std" "{" <body: StandardOp*> "}" => ConstExpr::StandardBuiltin(StandardBuiltin {
        name: format!("block"),
        args: vec![],
        ret: Type::Any,
        body,
    }).app(vec![]),
    <defs: List<"let", (<Symbol> <(":" <Type>)?> "=" <Math>), ",", "in">> <e: Expr> => {
        Expr::LetVars(defs, Box::new(e))
    },
    <defs: List<"type", (<Symbol> "=" <Type>), ",", "in">> <e: Expr> => {
        Expr::LetTypes(defs, Box::new(e))
    },
    <defs: List<"const", (<Symbol> "=" <ConstExpr>), ",", "in">> <e: Expr> => {
        Expr::LetConsts(defs.into_iter().collect(), Box::new(e))
    },
    "proc" <name: Symbol> <args: List<"(", (<Symbol> ":" <Type>), ",", ")">> "->" <ret: Type> "=" <body: Block> "in" <e: Expr> => {
        Expr::LetProc(name, Procedure::new(args, ret, body), Box::new(e))
    },
    "while" <cond: Expr> <body: Block> => Expr::While(Box::new(cond), Box::new(body)),
    <x: Factor> "=" <val: Expr> => x.refer().deref_mut(val),
    "&" <Expr> => <>.refer(),
    "*" <Expr> => <>.deref(),
    "return" <Expr> => Expr::Return(Box::new(<>)),
    Math => <>
}


Math: Expr = {
    <a: Math> "+" <b: Factor> => a.add(b),
    <a: Math> "-" <b: Factor> => a.sub(b),
    Factor => <>,
}

Factor: Expr = {
    <a: Factor> "*" <b: Term> => a.mul(b),
    <a: Factor> "/" <b: Term> => a.div(b),
    <a: Factor> "%" <b: Term> => a.rem(b),
    Term => <>,
}

Term: Expr = {
    <x: Term> "." <field: Symbol> => x.field(ConstExpr::Symbol(field)),
    <x: Term> "." <field: IntLit> => x.field(ConstExpr::Int(field as i32)),
    <x: Term> "->" <field: Symbol> => x.deref().field(ConstExpr::Symbol(field)),
    <x: Term> "->" <field: IntLit> => x.deref().field(ConstExpr::Int(field as i32)),
    <x: Term> "[" <idx: Expr> "]" => x.idx(idx),
    <x: Term> "as" <t: Type> => x.as_type(t),
    <f: Term> <args: List<"(", Expr, ",", ")">> => f.app(args),
    "if" <cond: Atom> <t: Atom> <e: ("else" <Atom>)?> => {
        Expr::If(Box::new(cond), Box::new(t), Box::new(e.unwrap_or(ConstExpr::None.into())))
    },
    Atom => <>,
}

Atom: Expr = {
    Block => <>,
    "(" <Expr> ")" => <>,
    ConstExpr => Expr::ConstExpr(<>),
    Tuple<Expr> => Expr::Tuple(<>),
    Array<Expr> => Expr::Array(<>),
    "struct" "{" <mut list:(<Symbol> "=" <Expr> ",")*> <last: (<Symbol> "=" <Expr>)> "}" => {
        list.push(last);
        Expr::Struct(list.into_iter().collect())
    },
    "union" "{" <mut list:(<Symbol> ":" <Type> ",")*> <last: (<Symbol> ":" <Type> "=" <Expr>)> "}" => {
        list.push((last.0.clone(), last.1));
        let t = Type::Union(list.into_iter().collect());
        Expr::Union(t, last.0, Box::new(last.2))
    },
    "union" "{" <name: Symbol> "=" <e: Expr> "," <t: Type> ".." "}" => {
        Expr::Union(t, name, Box::new(e))
    },
}

Block: Expr = {
    "{" <mut list: (<Expr> ";")*> <end:Expr?> "}" => {
        list.push(match end {
            Some(val) => val,
            None => ConstExpr::None.into()
        });
        Expr::Many(list)
    }
}

StringLit: String = <s:r#""(\\.|[^"])*""#> => String::from(&s[1..s.len()-1]).replace("\\\"", "\"").replace("\\n", "\n").replace("\\r", "\r").replace("\\t", "\t").replace("\\0", "\0");
CharLit: char = <s:r#"'(\\.|[^'])'"#> => s.replace("\\'", "'").replace("\\n", "\n").replace("\\r", "\r").replace("\\t", "\t").replace("\\0", "\0").chars().nth(1).unwrap() as char;
IntLit: isize = <s:r"-?[0-9]\d*"> => isize::from_str(s).unwrap();
FloatLit: f64 = {
    r"-?([1-9][0-9]*|[0])[.]([0-9]+)?" => <>.to_string().parse::<f64>().unwrap(),
}
Symbol: String = r"[a-zA-Z_][a-zA-Z0-9_]*" => <>.to_string();


Tuple<T>: Vec<T> = {
    "(" <mut list: (<T> ",")+> <end:T?> ")" => {
        match end {
            None => list,
            Some(val) => {
                list.push(val);
                list
            }
        }
    }
}

Array<T>: Vec<T> = List<"[", T, ",", "]"> => <>;
Dict<K, V>: Vec<(K, V)> = List<"{", (<K> ":" <V>), ",", "}"> => <>;

List<Begin, T, Sep, End>: Vec<T> = {
    <first:Begin> <list: (<T> <Sep>)*> <end:T?> <last:End> => {
        match end {
            None => list.iter().map(|(v, s)| v.clone()).collect(),
            Some(val) => {
                let mut list: Vec<_> = list.iter().map(|(v, s)| v.clone()).collect();
                list.push(val);
                list
            }
        }
    }
}


CoreOp: CoreOp = {
    "set" <Location> "," <IntLit> => CoreOp::Set(<>),
    "set" <Location> "," <Symbol> => CoreOp::SetLabel(<>),

    "lea" <addr: Location> "," <dst: Location> => CoreOp::GetAddress { addr, dst },

    "call" <Location> => CoreOp::Call(<>),
    "call" <Symbol> => CoreOp::CallLabel(<>),

    "ret" => CoreOp::Return,

    "fun" <Symbol> => CoreOp::Fn(<>),
    "while" <Location> => CoreOp::While(<>),
    "if" <Location> => CoreOp::If(<>),
    "else" => CoreOp::Else,
    "end" => CoreOp::End,
    
    "mov" <src: Location> "," <dst: Location> => CoreOp::Move { src, dst },
    "copy" <src: Location> "," <dst: Location> "," <size: IntLit> => CoreOp::Copy { src, dst, size: size as usize },
    
    "bitwise-nand" <src: Location> "," <dst: Location> => CoreOp::BitwiseNand { src, dst },
    "bitwise-and" <src: Location> "," <dst: Location> => CoreOp::BitwiseAnd { src, dst },
    "bitwise-xor" <src: Location> "," <dst: Location> => CoreOp::BitwiseXor { src, dst },
    "bitwise-or" <src: Location> "," <dst: Location> => CoreOp::BitwiseOr { src, dst },
    "bitwise-not" <Location> => CoreOp::BitwiseNot(<>),

    "next" <Location> <("," <IntLit>)?> => CoreOp::Next(<>),
    "prev" <Location> <("," <IntLit>)?> => CoreOp::Prev(<>),

    "index" <src: Location> "," <offset: Location> "," <dst: Location> => CoreOp::Index { src, offset, dst },
    "inc" <Location> => CoreOp::Inc(<>),
    "dec" <Location> => CoreOp::Dec(<>),
    "add" <src: Location> "," <dst: Location> => CoreOp::Add { src, dst },
    "sub" <src: Location> "," <dst: Location> => CoreOp::Sub { src, dst },
    "mul" <src: Location> "," <dst: Location> => CoreOp::Mul { src, dst },
    "div" <src: Location> "," <dst: Location> => CoreOp::Div { src, dst },
    "rem" <src: Location> "," <dst: Location> => CoreOp::Rem { src, dst },
    "div-rem" <src: Location> "," <dst: Location> => CoreOp::DivRem { src, dst },
    "neg" <Location> => CoreOp::Neg(<>),
    "not" <Location> => CoreOp::Not(<>),
    "and" <src: Location> "," <dst: Location> => CoreOp::And { src, dst },
    "or" <src: Location> "," <dst: Location> => CoreOp::Or { src, dst },

    "push" <src: Location> <size: ("," <IntLit>)?> => CoreOp::Push(src, size.unwrap_or(1) as usize),
    "pop" <dst: Location> "," <size: IntLit> => CoreOp::Pop(Some(dst), size as usize),
    "pop" <dst: Location> => CoreOp::Pop(Some(dst), 1),
    "pop" <size: IntLit> => CoreOp::Pop(None, size as usize),
    "pop" => CoreOp::Pop(None, 1),

    "push-to" <src: Location> "," <sp: Location> "," <size: IntLit> => CoreOp::PushTo { src, sp, size: size as usize },
    "pop-from" <sp: Location> <dst: ("," <Location>)?> "," <size: IntLit> => CoreOp::PopFrom { sp, dst, size: size as usize },

    "cmp" <a: Location> "," <b: Location> "," <dst: Location> => CoreOp::Compare { a, b, dst },
    "gt" <a: Location> "," <b: Location> "," <dst: Location> => CoreOp::IsGreater { a, b, dst },
    "gte" <a: Location> "," <b: Location> "," <dst: Location> => CoreOp::IsGreaterEqual { a, b, dst },
    "lt" <a: Location> "," <b: Location> "," <dst: Location> => CoreOp::IsLess { a, b, dst },
    "lte" <a: Location> "," <b: Location> "," <dst: Location> => CoreOp::IsLessEqual { a, b, dst },
    "eq" <a: Location> "," <b: Location> "," <dst: Location> => CoreOp::IsEqual { a, b, dst },
    "neq" <a: Location> "," <b: Location> "," <dst: Location> => CoreOp::IsNotEqual { a, b, dst },

    "put" <Location> => CoreOp::Put(<>),
    "get" <Location> => CoreOp::Get(<>),

    "array" <src: Location> "," <vals: List<"[", IntLit, ",", "]">> "," <dst: Location> => CoreOp::Array {
        src, dst, vals
    },
    "array" <src: Location> "," <vals: StringLit> "," <dst: Location> => {
        let mut vals: Vec<isize> = vals.chars().map(|c| c as isize).collect();
        vals.push(0);
        CoreOp::Array { src, dst, vals }
    }
}

StandardOp: StandardOp = {
    CoreOp => StandardOp::CoreOp(<>),
    "set-f" <Location> "," <FloatLit> => StandardOp::Set(<>),
    "to-float" <Location> => StandardOp::ToFloat(<>),
    "to-int" <Location> => StandardOp::ToInt(<>),
    
    "pow" <src: Location> "," <dst: Location> => StandardOp::Pow { src, dst },
    "sqrt" <Location> => StandardOp::Sqrt(<>),
    "add-f" <src: Location> "," <dst: Location> => StandardOp::Add { src, dst },
    "sub-f" <src: Location> "," <dst: Location> => StandardOp::Sub { src, dst },
    "mul-f" <src: Location> "," <dst: Location> => StandardOp::Mul { src, dst },
    "div-f" <src: Location> "," <dst: Location> => StandardOp::Div { src, dst },
    "rem-f" <src: Location> "," <dst: Location> => StandardOp::Rem { src, dst },
    "neg-f" <Location> => StandardOp::Neg(<>),

    "sin" <Location> => StandardOp::Sin(<>),
    "cos" <Location> => StandardOp::Cos(<>),
    "tan" <Location> => StandardOp::Tan(<>),
    "asin" <Location> => StandardOp::ASin(<>),
    "acos" <Location> => StandardOp::ACos(<>),
    "atan" <Location> => StandardOp::ATan(<>),

    "gt-f" <a: Location> "," <b: Location> "," <dst: Location> => StandardOp::IsGreater { a, b, dst },
    "lt-f" <a: Location> "," <b: Location> "," <dst: Location> => StandardOp::IsLess { a, b, dst },

    "alloc" <Location> => StandardOp::Alloc(<>),
    "free" <Location> => StandardOp::Free(<>),

    "put-char" <Location> => StandardOp::PutChar(<>),
    "get-char" <Location> => StandardOp::GetChar(<>),
    "put-int" <Location> => StandardOp::PutInt(<>),
    "get-int" <Location> => StandardOp::GetInt(<>),
    "put-float" <Location> => StandardOp::PutFloat(<>),
    "get-float" <Location> => StandardOp::GetFloat(<>),
}

Location: Location = {
    "[" <deref: Location> "+" <offset: IntLit> "]" => deref.deref().offset(offset),
    "[" <deref: Location> "-" <offset: IntLit> "]" => deref.deref().offset(-offset),
    "[" <Location> "]" => <>.deref(),

    "A" => A,
    "B" => B,
    "C" => C,
    "D" => D,
    "E" => E,
    "F" => F,
    "SP" => SP,
    "FP" => FP,
}